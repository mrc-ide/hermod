---
title: "hipercow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hipercow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
source("common.R")
vignette_root <- new_hipercow_root_path()
set_vignette_root(vignette_root)
fs::file_copy("simulation.R", vignette_root)
```

```{r, echo = FALSE, results = "asis"}
add_header()
```

Parallel computing on a cluster can be more challenging than running things locally because it's often the first time that you need to package up code to run elsewhere, and when things go wrong it's more difficult to get information on why things failed.

Much of the difficulty of getting things running involves working out what your code depends on, and getting that installed in the right place on a computer that you can't physically poke at.  The next set of problems is dealing with the ballooning set of files that end up being created - templates, scripts, output files, etc.

The `hipercow` package aims to remove some of this pain, with the aim that running a task on the cluster should be (almost) as straightforward as running things locally, at least once some basic setup is done.

At the moment, this document assumes that we will be using the "windows" cluster, which implies the existence of some future non-windows cluster. Stay tuned.

This manual is structured in escalating complexity, following the chain of things that a hypothetical user might encounter as they move from their first steps on the cluster through to running enormous batches of tasks.

# Installing prerequisites

Install the required packages from our "r-universe". Be sure to run this in a fresh session.

```r
install.packages(
  "hipercow",
  repos = c("https://mrc-ide.r-universe.dev", "https://cloud.r-project.org"))
```

Once installed you can load the package with

```{r}
library(hipercow)
```

or use the package by prefixing the calls below with `hipercow::`, as you prefer.

# Authentication with DIDE

First run the `windows_authenticate()` function which will talk you through entering your credentials and checking that they work. You only need to do this *once per machine, each time you change your password*.

A typical interaction with this looks like:

```
> windows_authenticate()
I need to unlock the system keychain in order to load and save
your credentials.  This might differ from your DIDE password,
and will be the password you use to log in to this particular
machine
Keyring password:
ðŸ”‘  OK

â”€â”€ Please enter your DIDE credentials â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
We need to know your DIDE username and password in order to log
you into the cluster. This will be shared across all projects
on this machine, with the username and password stored securely
in your system keychain. You will have to run this command
again on other computers

Your DIDE password may differ from your Imperial password, and
in some cases your username may also differ. If in doubt,
perhaps try logging in at https://mrcdata.dide.ic.ac.uk/hpc and
use the combination that works for you there.

DIDE username (default: rfitzjoh) >
Password:
ðŸ”‘  OK

I am going to try and log in with your password now, if this
fails we can always try again, as failure is just the first
step towards great success.
Excellent news! Everything seems to work!
```

# Filesystems and paths

We need a concept of a "root"; the point in the filesystem we can think of everything relative to.  This will feel familiar to you if you have used git or orderly, as these all have a root (and this root will be a fine place to put your cluster work). Typically all paths will be *within* this root directory, and paths above it, or absolute paths in general, effectively cease to exist. If your project works this way then it's easy to move around, which is exactly what we need to do in order to run it on the cluster.

The Windows cluster needs everything to be available on a filesystem
that the cluster can read.  Practically this means the filesystems
`//fi--didef3.dide.ic.ac.uk/tmp` or `//fi--san03.dide.ic.ac.uk/homes/username` and the like.
You probably have access to network shares that are specific to a
project, too.  For Windows users these are probably mapped to
drives (`Q:` or `T:` or similar) already, but for other platforms
you will need to do a little extra work to get things set up.

In general we **strongly recommend** that you use project shares for any serious work, rather than your home directory.  To organise these you should talk to your PI (or if you are a PI, talk to Chris).  The advantages of the project shares is that they are larger (so you will run out of disk space more slowly) and faster than the home shares.  If you launch many tasks at once that use your home share you can get unexpected failures as the disk can't keep up with amount of data being read and written.

*To set up your shares, or learn more, please see the "Paths and shares" section in `vignette("details")`.*

Set your working directory to be on the share by loading an [RStudio project](https://support.posit.co/hc/en-us/articles/200526207-Using-RStudio-Projects) (or if you must, by using `setwd()`), and then you can write:

```{r init}
hipercow_init(driver = "windows")
```

which will write things to a new path `hipercow/` within your working directory and set you up to use the windows cluster, which is the only option at present.

By default, we aim to automatically detect your shares, and we believe this works on Windows, macOS and Linux.  If you are running on a network share and the configuration errors because it cannot work out what share you are on, please let us know.

You can see the computed configuration by running `hipercow_configuration()`:

```{r}
hipercow_configuration()
```

Here, you can see versions of important packages, information about where you are working, and information about how you intend to interact with the windows cluster (the cluster name, the mapping if the current directory into something the cluster understands, and the version of R that tasks will run on when running on the cluster).  If you have issues with `hipercow` we will always want to see the output of `hipercow_configuration()`.

# Running your first task

The first time you use the tools (ever, in a while, or on a new machine) we recommend sending off a tiny task to make sure that everything is working as expected:

```{r create}
id <- task_create_expr(sessionInfo())
```

This creates a new task that will run the expression `sessionInfo()` on the cluster. The `task_create_expr()` function works by so-called ["non standard evaluation"](https://adv-r.hadley.nz/metaprogramming.html) and the expression is not evaluated from your R session, but sent to run on another machine.

The `id` returned is just an ugly hex string:

```{r}
id
```

```{r, include = FALSE}
# Ensure that the task is finished, makes the rest of the doc nicer to read
task_wait(id)
```

Many other functions accept this `id` as an argument.  You can get the status of the task, which will have finished now because it really does not take very long:

```{r status}
task_status(id)
```

Once the task has completed you can inspect the result:

```{r result}
task_result(id)
```

You can see that this result is different from what we'd get by running `sessionInfo()` locally:

```{r}
sessionInfo()
```

# Using functions you have written

It's unlikely that the code you want to run on the cluster is one of the functions built into R itself; more likely you have written a simulation or similar and you want to run *that* instead.  In order to do this, we need to tell the cluster where to find your code. There are two broad places where code that you want to run is likely to be found **script files** and **packages**; we start with the former here, and deal with packages in much more detail in `vignette("packages")`.

Suppose you have a file `simulation.R` containing some simulation:

```{r, results = "asis", echo = FALSE}
r_output(readLines("simulation.R"))
```

We can't run this on the cluster immediately, because the cluster does not know about the new function:

```{r create_walk1}
id <- task_create_expr(random_walk(0, 10))
task_wait(id)
task_status(id)
task_result(id)
```

(See `vignette("troubleshooting")` for more on failures.)

We need to tell hipercow to `source()` the file `simulation.R` before running the task. To do this we use `hipercow_environment_create()` to create an "environment" (not to be confused with R's environments) in which to run things:

```{r create_environment}
hipercow_environment_create(sources = "simulation.R")
```

Now we can run our simulation:

```{r create_walk2}
id <- task_create_expr(random_walk(0, 10))
task_wait(id)
task_result(id)
```

# Getting information about tasks

Once you have created (and submitted) tasks, they will be queued by the cluster and eventually run.  The hope is that we surface enough information to make it easy for you to see how things are going and what has gone wrong.

## Fetching times with `task_info()`

```{r}
task_info(id)
```

This prints out information about the task; its identifier (`r inline(id)`) and status (`success`), along with the time that key events happened for the task (when it was created, started and finished).

This display is meant to be friendly; if you need to compute on this information, you can access the times by reading the `$times` element of the `task_info()` return value:

```{r}
task_info(id)$times
```

## Fetching logs with `task_log_show`

Every task will produce some logs, and these can be an important part of understanding what they did and why they went wrong.

You can view the log with `task_log_show()`

```{r}
task_log_show(id)
```

This prints the contents of the logs to the screen; you can access the values directly with `task_log_value(id)`.  The format of the logs will be generally the same for all tasks; after the header saying where we are running, some information about the task will be printed (its identifier, the time, details about the task itself), then any logs that come from calls to `message()` and `print()` within the queued function (within the "task logs" section; here that is empty because our task prints nothing).  Finally, a summary will be printed with the final status, final time (and elapsed time), then any warnings that were produced will be flushed (see `vignette("troubleshooting")` for more on warnings).

There is a second log too, the "outer" log, which is generally less interesting so it is not the default.  These logs come from the cluster scheduler itself and show the startup process that leads up to (and after) the code that hipercow itself runs.  It will differ from driver to driver.  In addition, this log may not be available forever; the windows cluster retains it only for a couple of weeks:

```{r}
task_log_show(id, outer = TRUE)
```

The logs returned by `task_log_show(id, outer = FALSE)` are the logs generated by the statement containing `Rscript -e`.

## Watching logs with `task_log_watch`

If your task is still running, you can stream logs to your computer using `task_log_watch()`; this will print new logs line-by-line as they arrive (with a delay of up to 1s by default). This can be useful while debugging something to give the illusion that you're running it locally.

Using `Ctrl-C` (or `ESC`) to escape will only stop log streaming and not the underlying task.

# Understanding where variables come from

Suppose our simulation started not from 0, but from some point that we have computed locally (say `x`, imaginatively)

```{r}
x <- 100
```

You can use this value to start the simulation by running:

```{r create_walk3}
id <- task_create_expr(random_walk(x, 10))
```

Here the `x` value has come from the environment where the expression passed into `task_create_expr()` was found (specifically, we use the [`rlang` "tidy evaluation"](https://rlang.r-lib.org/reference/topic-defuse.html) framework you might be familiar with from `dplyr` and friends).

```{r result3}
task_wait(id)
task_result(id)
```

If you pass in an expression that references a value that does not exist locally, you will get a (hopefully) informative error message when the task is created:

```{r, error = TRUE}
id <- task_create_expr(random_walk(starting_point, 10))
```

# Cancelling tasks

You can cancel a task if it has been submitted and not completed, using `task_cancel`:

For example, here's a task that will sleep for 10 minutes, which we submit to the cluster:

```{r}
id <- task_create_expr(Sys.sleep(600))
```

```{r, include = FALSE}
for (i in 1:100) {
  Sys.sleep(0.1)
  status <- task_status(id)
  if (status != "submitted") {
    break
  }
}
if (status != "running") {
  stop("Failed to get the task running in time")
}
```

This task is now running:

```{r}
task_status(id)
task_info(id)
```

Having decided that this is a silly idea, we can cancel it:

```{r}
task_cancel(id)
task_status(id)
task_info(id)
```

You can cancel a task that is submitted (waiting to be picked up by a cluster) or running.  You can cancel many tasks at once by passing a vector of identifiers through.

# Retrying tasks

There are lots of reasons why you might want to retry a task.  For example:

* it failed but you think it might work next time
* you updated a package that it used, and want to try again with the new version
* you don't like the output from some stochastic function and want to generate new output
* you cancelled the task but want to try again now

You can retry tasks with `task_retry()`, which is easier than submitting a new task with the same content, and also preserves a link between retried tasks.

Our random walk will give slightly different results each time we use it, so we demonstrate the idea with that:

```{r}
id1 <- task_create_expr(random_walk(0, 10))
task_wait(id1)
task_result(id1)
```

Here we ran a random walk and it got to `r tail(task_result(id1), 1)`, which is clearly not what we were expecting.  Let's try it again:

```{r}
id2 <- task_retry(id1)
```

Running `task_retry` creates a *new* task, with a new id `r abbrev_id(id2)` compared with `r abbrev_id(id1)`.

Once this task has finished, we get a different result:

```{r}
task_wait(id2)
task_result(id2)
```

Much better!

We get a hint that this is a retried task from the `task_info`

```{r}
task_info(id2)
```

You can see the full chain of retries here:

```{r}
task_info(id2)$chain
```

Once a task has been retried it affects how you interact with the previous ids; by default they follow through to the most recent element in the chain:

```{r}
task_result(id1)
task_result(id2)
```

You can get the original result back by using `follow = FALSE`:

```{r}
task_result(id1, follow = FALSE)
task_result(id2)
```

Only tasks that have been completed (`success`, `failure` or `cancelled`) can be retried, and doing so adds a new task to the *end* of the chain; there is no branching. Retrying the `id1` here would create the chain `id1 -> id2 -> id3`, and following would select `id3` for any of the three tasks in the chain.

You cannot currently change any property of a retried task, we may change this in future.
