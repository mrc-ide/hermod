##' Create an explicit task. Explicit tasks are the simplest sort of
##' task in hipercow and do nothing magic. They accept an R expression
##' (from `quote` or friends) and possibly a set of variables to
##' export from the global environment.  This can then be run on a
##' cluster by loading your variables and running your expression.  If
##' your expression depends on packages being *attached* then you
##' should pass a vector of package names too.  This function may
##' disappear, and is used by us to think about the package, it's not
##' designed to really be used.
##'
##' @title Create explicit task
##'
##' @param expr Unevaluated expression object, e.g., from `quote`
##'
##' @param export Optional character vector of names of objects to
##'   export into the evaluating environment
##'
##' @param envir Local R environment in which to find variables for
##'   `export`. The default is the parent frame, which will
##'   often do the right thing.  Another sensible choice is
##'   `.GlobalEnv` to use the global environment.
##'
##' @param environment Name of the hipercow environment to evaluate the
##'   task within.
##'
##'
##' @param driver Name of the driver to use to submit the task.  The
##'   default (`NULL`) depends on your configured drivers; if you have
##'   no drivers configured no submission happens (or indeed is
##'   possible).  If you have exactly one driver configured we'll
##'   submit your task with it.  If you have more than one driver
##'   configured, then we will error, though in future versions we may
##'   fall back on a default driver if you have one configured.  If
##'   you pass `FALSE` here, submission is prevented even if you have
##'   no driver configured.
##'
##' @param resources A list generated by [hipercow_resources] giving
##'   the cluster resource requirements to run your task.
##'
##' @param envvars Environment variables as generated by
##'   [hipercow_envvars], which you might use to control your task.
##'   These will be combined with the default environment variables
##'   (see `vignettes("details")`, this can be overridden by the
##'   option `hipercow.default_envvars`), and any driver-specific
##'   environment variables (see `vignette("windows")`).  Variables
##'   provided here have the highest precedence.  You can **unset** an
##'   environment variable by setting it to `NA`.
##'
##' @param parallel Parallel configuration as generated by
##'   [hipercow_parallel], which defines which method, if any, will be used
##'   to initialise your task for parallel execution.
##'
##' @inheritParams task_eval
##'
##' @return A task id, a string of hex characters. Use this to
##'   interact with the task.
##'
##' @export
##' @examples
##' cleanup <- hipercow_example_helper()
##'
##' # About the most simple task that can be created:
##' id <- task_create_explicit(quote(sqrt(2)))
##' task_wait(id)
##' task_result(id)
##'
##' # Variables are not automatically included with the expression:
##' a <- 5
##' id <- task_create_explicit(quote(sqrt(a)))
##' task_info(id)
##' task_wait(id)
##' task_result(id)
##'
##' # Include variables by passing them via 'export':
##' id <- task_create_explicit(quote(sqrt(a)), export = "a")
##' task_info(id)
##' task_wait(id)
##' task_result(id)
##'
##' cleanup()
task_create_explicit <- function(expr, export = NULL, envir = parent.frame(),
                                 environment = "default", driver = NULL,
                                 resources = NULL, envvars = NULL,
                                 parallel = NULL, root = NULL) {
  root <- hipercow_root(root)
  driver <- driver_before_create(driver, root, rlang::current_env())
  resources <- resources_validate(resources, driver, root)
  ## TODO: this would be safer done in task_create, but do that in
  ## another PR.
  parallel <- parallel_validate(parallel, resources$cores, environment, driver,
                                root, rlang::current_env())
  envvars <- prepare_envvars(envvars, driver, root, rlang::current_env())
  variables <- task_variables(export, envir, environment, root,
                              rlang::current_env())
  path <- relative_workdir(root$path$root)
  id <- task_create(root, "explicit", path, environment, envvars, parallel,
                    expr = expr, variables = variables)
  task_submit_maybe(id, driver, resources, root, rlang::current_env())
  id
}


##' Create a task based on an expression. This is similar to
##' [task_create_explicit] except more magic, and is closer to
##' the interface that we expect people will use.
##'
##' The expression passed as `expr` will typically be a function call
##' (e.g., `f(x)`).  We will analyse the expression and find all
##' variables that you reference (in the case of `f(x)` this is `x`)
##' and combine this with the function name to run on the cluster.  If
##' `x` cannot be found in your calling environment we will error;
##' this behaviour is subject to change so let us know if you have
##' other thoughts.
##'
##' Alternatively you may provide a multiline statement by using `{}`
##' to surround multiple lines, such as:
##'
##' ```
##' task_create_expr({
##'   x <- runif(1)
##'   f(x)
##' }, ...)
##' ```
##'
##' in this case, we apply a simple heuristic to work out that `x` is
##' locally assigned and should not be saved with the expression.
##'
##' If you reference values that require a lot of memory, `hipercow`
##' will error and refuse to save the task.  This is to prevent you
##' accidentally including values that you will make available through an
##' environment, and to prevent making the `hipercow` directory
##' excessively large.  Docs on controlling this process are still to
##' be written.
##'
##' @title Create a task based on an expression
##'
##' @param expr The expression, does not need quoting. See Details.
##'
##' @inheritParams task_create_explicit
##'
##' @inherit task_create_explicit return
##' @export
##' @examples
##' cleanup <- hipercow_example_helper()
##'
##' # Similar to task_create_explicit, but we don't include the 'quote'
##' id <- task_create_expr(runif(5))
##' task_wait(id)
##' task_result(id)
##'
##' # Unlike task_create_explicit, variables are automatically included:
##' n <- 3
##' id <- task_create_expr(runif(n))
##' task_info(id)
##' task_wait(id)
##' task_result(id)
##'
##' cleanup()
task_create_expr <- function(expr, environment = "default", driver = NULL,
                             resources = NULL, envvars = NULL,
                             parallel = NULL, root = NULL) {
  root <- hipercow_root(root)
  driver <- driver_before_create(driver, root, rlang::current_env())
  expr <- check_expression(rlang::enquo(expr))
  resources <- resources_validate(resources, driver, root)
  parallel <- parallel_validate(parallel, resources$cores, environment, driver,
                                root, rlang::current_env())
  envvars <- prepare_envvars(envvars, driver, root, rlang::current_env())
  variables <- task_variables(
    find_vars(expr$value), expr$envir, environment, root,
    rlang::current_env())
  path <- relative_workdir(root$path$root)
  id <- task_create(root, "expression", path, environment, envvars, parallel,
                    expr = expr$value, variables = variables)

  task_submit_maybe(id, driver, resources, root, rlang::current_env())
  id
}


##' Create a task from a script.  This will arrange to run the file
##' `script` via hipercow.  The script must exist within your hipercow
##' root, but you may change to the directory of the script as it
##' executes (otherwise we will evaluate from your current directory
##' relative to the hipercow root, as usual).
##'
##' @title Create script task
##'
##' @param script Path for the script
##'
##' @param chdir Logical, indicating if we should change the working
##'   directory to the directory containing `script` before executing
##'   it (similar to the `chdir` argument to [`source`]).
##'
##' @param echo Passed through to `source` to control printing while
##'   evaluating.  Generally you will want to leave this as `TRUE`
##'
##' @inheritParams task_create_explicit
##'
##' @return A task id, a string of hex characters. Use this to
##'   interact with the task.
##'
##' @export
##' @examples
##' cleanup <- hipercow_example_helper()
##'
##' # Create a small script; this would usually be several lines of
##' # course.  The script will need to do something as a side effect
##' # to be worth calling, so here we write a file.
##' writeLines("saveRDS(mtcars, 'data.rds')", "script.R")
##'
##' # Now create a task from this script
##' id <- task_create_script("script.R")
##' task_info(id)
##' task_wait(id)
##' task_result(id)
##' dir()
##'
##' cleanup()
task_create_script <- function(script, chdir = FALSE, echo = TRUE,
                               environment = "default", driver = NULL,
                               resources = NULL, envvars = NULL,
                               parallel = NULL, root = NULL) {
  root <- hipercow_root(root)
  driver <- driver_before_create(driver, root, rlang::current_env())
  if (!file.exists(script)) {
    cli::cli_abort("Script file '{script}' does not exist")
  }
  if (!fs::path_has_parent(script, root$path$root)) {
    cli::cli_abort(
      "Script file '{script}' is not contained within hipercow root")
  }
  resources <- resources_validate(resources, driver, root)
  parallel <- parallel_validate(parallel, resources$cores, environment, driver,
                                root, rlang::current_env())
  envvars <- prepare_envvars(envvars, driver, root, rlang::current_env())
  path <- relative_workdir(root$path$root)
  script <- as.character(fs::path_rel(script, getwd()))
  assert_scalar_logical(chdir, call = rlang::current_env())
  ensure_environment_exists(environment, root, rlang::current_env())

  id <- task_create(root, "script", path, environment, envvars, parallel,
                    script = script, chdir = chdir, echo = echo)
  task_submit_maybe(id, driver, resources, root, rlang::current_env())
  id
}


##' Create a task based on a function call.  This is fairly similar to
##' [callr::r], and forms the basis of [lapply()]-like task
##' submission.  Sending a call may have slightly different semantics
##' than you expect if you send a closure (a function that binds
##' data), and we may change behaviour here until we find a happy set
##' of compromises.  See Details for more on this.  The expression
##' `task_create_call(f, list(a, b, c))` is similar to
##' `task_create_expr(f(a, b, c))`, use whichever you prefer.
##'
##' Things are pretty unambiguous when you pass in a function from a
##' package, especially when you refer to that package with its
##' namespace (e.g. `pkg::fn`).
##'
##' If you pass in the name *without a namespace* from a package that
##' you have loaded with `library()` locally but you have not loaded
##' with `library` within your hipercow environment, we may not do the
##' right thing and you may see your task fail, or find a different
##' function with the same name.  We may change the semantics here in
##' a future version to attach your package immediately before running
##' the task.
##'
##' If you pass in an anonymous function (e.g., `function(x) x + 1`)
##' we may or may not do the right thing with respect to environment
##' capture.  We never capture the global environment so if your
##' function is a closure that tries to bind a symbol from the global
##' environment it will not work.  Like with `callr::r`, anonymous
##' functions will be easiest to think about where they are fully self
##' contained (i.e., all inputs to the functions come through `args`).
##' If you have bound a *local* environment, we may do slightly
##' better, but semantics here are undefined and subject to change.
##'
##' R does some fancy things with function calls that we don't try to
##' replicate.  In particular you may have noticed that this works:
##'
##' ```
##' c <- "x"
##' c(c, c) # a vector of two "x"'s
##' ```
##'
##' You can end up in this situation locally with:
##'
##' ```
##' f <- function(x) x + 1
##' local({
##'   f <- 1
##'   f(f) # 2
##' })
##' ```
##'
##' this is because when R looks for the symbol for the call it skips
##' over non-function objects.  We don't reconstruct environment
##' chains in exactly the same way as you would have locally so this
##' is not possible.
##'
##' @title Create task from call
##'
##' @param fn The function to call.
##'
##' @param args A list of arguments to pass to the function
##'
##' @inheritParams task_create_expr
##'
##' @return A task id, a string of hex characters. Use this to
##'   interact with the task.
##'
##' @export
##' @examples
##' cleanup <- hipercow_example_helper()
##'
##' # Similar to the example in task_create_call
##' id <- task_create_call(stats::runif, list(5))
##' task_info(id)
##' task_wait(id)
##' task_result(id)
##'
##' # Unlike task_create_explicit, variables are automatically included:
##' id <- task_create_call(function(x, y) x + y, list(2, 5))
##' task_info(id)
##' task_wait(id)
##' task_result(id)
##'
##' cleanup()
task_create_call <- function(fn, args, environment = "default", driver = NULL,
                             resources = NULL, envvars = NULL, parallel = NULL,
                             root = NULL) {
  root <- hipercow_root(root)
  driver <- driver_before_create(driver, root, rlang::current_env())
  fn <- check_function(rlang::enquo(fn), rlang::current_env())
  args <- check_args(args)
  resources <- resources_validate(resources, driver, root)
  parallel <- parallel_validate(parallel, resources$cores, environment, driver,
                                root, rlang::current_env())
  envvars <- prepare_envvars(envvars, driver, root, rlang::current_env())
  path <- relative_workdir(root$path$root)
  id <- task_create(root, "call", path, environment, envvars, parallel,
                    fn = fn, args = args)
  task_submit_maybe(id, driver, resources, root, rlang::current_env())
  id
}


##' Create a bulk set of tasks. This is an experimental interface and
##' does not have an analogue within didehpc.  Variables in `data`
##' take precedence over variables in the environment in which `expr`
##' was created. There is no "pronoun" support yet (see rlang docs).
##' Use `!!` to pull a variable from the environment if you need to,
##' but be careful not to inject something really large (e.g., any
##' vector really) or you'll end up with a revolting expression and
##' poor backtraces.  We will likely change some of these semantics
##' later, be careful.
##'
##' @title Create bulk tasks from an expression
##'
##' @param expr An expression, as for [task_create_expr]
##'
##' @param data Data that you wish to inject _row-wise_ into the expression
##'
##' @param bundle_name Name to pass to [`hipercow_bundle_create`] when
##'   making a bundle. If `NULL` we use a random name.  We always
##'   overwrite, so if `bundle_name` already refers to a bundle it
##'   will be replaced.
##'
##' @inheritParams task_create_explicit
##'
##' @return A `hipercow_bundle` object, which groups together tasks,
##'   and for which you can use a set of grouped functions to get
##'   status (`hipercow_bundle_status`), results
##'   (`hipercow_bundle_result`) etc.
##'
##' @export
##'
##' @seealso [hipercow_bundle_wait], [hipercow_bundle_result] for
##'   working with bundles of tasks
##'
##' @examples
##' cleanup <- hipercow_example_helper()
##'
##' # Suppose we have a data.frame:
##' d <- data.frame(a = 1:5, b = runif(5))
##'
##' # We can create a "bundle" by applying an expression involving "a"
##' # and "b":
##' bundle <- task_create_bulk_expr(sqrt(a * b), d)
##'
##' # Once you have your bundle, interact with it using the bundle
##' # analogues of the usual task functions:
##' hipercow_bundle_wait(bundle)
##' hipercow_bundle_result(bundle)
##'
##' cleanup()
task_create_bulk_expr <- function(expr, data, environment = "default",
                                  bundle_name = NULL, driver = NULL,
                                  resources = NULL, envvars = NULL,
                                  parallel = NULL, root = NULL) {
  root <- hipercow_root(root)
  driver <- driver_before_create(driver, root, rlang::current_env())
  resources <- resources_validate(resources, driver, root)
  parallel <- parallel_validate(parallel, resources$cores, environment, driver,
                                root, rlang::current_env())
  envvars <- prepare_envvars(envvars, driver, root, rlang::current_env())

  if (!inherits(data, "data.frame")) {
    cli::cli_abort("Expected 'data' to be a data.frame (or tbl, etc)",
                   arg = "data")
  }
  if (nrow(data) == 0) {
    cli::cli_abort("'data' must have at least one row", arg = "data")
  }

  ## This will allow `!!x` to reference a value in the enclosing
  ## environment and we'll splice it into the expression. This will
  ## work pretty well for simple things and _terribly_ for large
  ## objects, which would be better pulled in by name if possible.
  ##
  ## We could do this using "eval_tidy" and use "pronouns" but that
  ## will require a little more setup; probably worth considering
  ## though.  For now this is fine, but we can improve this by:
  ##
  ## * Not doing the injection until later
  ## * Setting up the bits for eval_tidy and exporting them
  ## * Analysing the expression before injection and making sure
  ##   that anything injected is small
  expr <- check_expression(rlang::inject(rlang::enquo(expr)))

  ## Warn about lack of overlap here? That is, if there's nothing
  ## within locals that could be referenced from the data.frame that's
  ## likely an error.
  extra <- setdiff(find_vars(expr$value), names(data))
  variables <- task_variables(
    extra, expr$envir, environment, root, rlang::current_env())
  path <- relative_workdir(root$path$root)
  id <- vcapply(df_rows(data), function(x) {
    variables_i <- variables
    variables_i$locals <- c(variables$locals, x)
    task_create(root, "expression", path, environment, envvars, parallel,
                expr = expr$value, variables = variables_i)
  })
  task_submit_maybe(id, driver, resources, root, rlang::current_env())
  hipercow_bundle_create(
    id, name = bundle_name, validate = FALSE, overwrite = TRUE, root = NULL)
}


##' Create a bulk set of tasks based on applying a function over a
##' vector or [data.frame].  This is the bulk equivalent of
##' [task_create_call], in the same way that [task_create_bulk_expr]
##' is a bulk version of [task_create_expr].
##'
##' @title Create bulk tasks from a call
##'
##' @param fn The function to call
##'
##' @param data The data to apply the function over.  This can be a
##'   vector or list, in which case we act like `lapply` and apply
##'   `fn` to each element in turn.  Alternatively, this can be a
##'   [data.frame], in which case each row is taken as a set of
##'   arguments to `fn`.  Note that if `data` is a `data.frame` then
##'   all arguments to `fn` are named.
##'
##' @param args Additional arguments to `fn`, shared across all calls.
##'   These must be named.  If you are using a `data.frame` for
##'   `data`, you'd probably be better off adding additional columns
##'   that don't vary across rows, but the end result is the same.
##'
##' @inheritParams task_create_bulk_expr
##'
##' @inherit task_create_bulk_expr return
##' @export
##' @examples
##' cleanup <- hipercow_example_helper()
##'
##' # The simplest way to use this function is like lapply:
##' x <- runif(5)
##' bundle <- task_create_bulk_call(sqrt, x)
##' hipercow_bundle_wait(bundle)
##' hipercow_bundle_result(bundle) # lapply(x, sqrt)
##'
##' # You can pass additional arguments in via 'args':
##' x <- runif(5)
##' bundle <- task_create_bulk_call(log, x, list(base = 3))
##' hipercow_bundle_wait(bundle)
##' hipercow_bundle_result(bundle) # lapply(x, log, base = 3)
##'
##' # Passing in a data.frame acts like Map (though with all arguments named)
##' x <- data.frame(a = runif(5), b = rpois(5, 10))
##' bundle <- task_create_bulk_call(function(a, b) sum(rnorm(b)) / a, x)
##' hipercow_bundle_wait(bundle)
##' hipercow_bundle_result(bundle) # Map(f, x$a, x$b)
##'
##' cleanup()
task_create_bulk_call <- function(fn, data, args = NULL,
                                  environment = "default", bundle_name = NULL,
                                  driver = NULL, resources = NULL,
                                  envvars = NULL, parallel = NULL,
                                  root = NULL) {
  root <- hipercow_root(root)
  driver <- driver_before_create(driver, root, rlang::current_env())
  resources <- resources_validate(resources, driver, root)
  parallel <- parallel_validate(parallel, resources$cores, environment, driver,
                                root, rlang::current_env())
  envvars <- prepare_envvars(envvars, driver, root, rlang::current_env())

  fn <- check_function(rlang::enquo(fn), rlang::current_env())
  if (!is.null(args)) {
    args <- check_args(args)
  }
  path <- relative_workdir(root$path$root)

  is_data_frame <- inherits(data, "data.frame")
  if (is_data_frame) {
    data <- df_rows(data)
  } else {
    data <- lapply(data, list)
  }
  if (length(data) == 0) {
    cli::cli_abort(
      "'data' must have at least one {if (is_data_frame) 'row' else 'element'}",
      arg = "data")
  }

  id <- vcapply(data, function(x) {
    task_create(root, "call", path, environment, envvars, parallel,
                fn = fn, args = c(x, args))
  })

  task_submit_maybe(id, driver, resources, root, rlang::current_env())
  hipercow_bundle_create(
    id, name = bundle_name, validate = FALSE, overwrite = TRUE, root = NULL)
}


task_export_envvars <- function(root, dst, envvars, inherit_envvars) {
  if (is.null(inherit_envvars)) {
    envvars_export(envvars, dst)
  } else {
    src <- file.path(path_task(root$path$tasks, inherit_envvars), RENVIRON)
    fs::file_create(dst)
    if (fs::file_exists(src)) {
      fs::file_copy(src, dst, overwrite = TRUE)
    }
  }
}


task_create <- function(root, type, path, environment, envvars,
                        parallel, ..., id = ids::random_id(),
                        inherit_envvars = NULL) {
  time <- Sys.time()
  dest <- path_task(root$path$tasks, id)
  fs::dir_create(dest)
  data <- list(type = type, id = id, time = time,
               path = path, environment = environment, envvars = envvars,
               parallel = parallel, ...)
  saveRDS(data, file.path(dest, DATA))
  task_export_envvars(root, file.path(dest, RENVIRON), envvars, inherit_envvars)

  id
}


check_expression <- function(quo) {
  if (rlang::quo_is_symbol(quo)) {
    sym <- rlang::as_name(rlang::quo_get_expr(quo))
    envir <- rlang::quo_get_env(quo)
    if (!rlang::env_has(envir, sym, inherit = TRUE)) {
      cli::cli_abort("Could not find expression '{sym}'")
    }
    expr <- rlang::env_get(envir, sym, inherit = TRUE)
    if (!rlang::is_call(expr)) {
      cli::cli_abort(c(
        "Expected 'expr' to be a function call",
        i = paste("You passed a symbol '{sym}', but that turned out to be",
                  "an object of type {typeof(expr)} and not a call")))
    }
  } else {
    if (!rlang::quo_is_call(quo)) {
      cli::cli_abort("Expected 'expr' to be a function call")
    }
    envir <- rlang::quo_get_env(quo)
    expr <- rlang::quo_get_expr(quo)
  }

  if (rlang::is_call(expr, "quote")) {
    given <- rlang::expr_deparse(expr)
    alt <- rlang::expr_deparse(expr[[2]])
    cli::cli_abort(
      c("You have an extra layer of quote() around 'expr'",
        i = "You passed '{given}' but probably meant to pass '{alt}'"))
  }
  list(value = expr, envir = envir)
}


task_variables <- function(names, envir, environment, root, call = NULL) {
  if (length(names) == 0) {
    ensure_environment_exists(environment, root, rlang::current_env())
    NULL
  } else {
    in_environment <- environment_load(environment, root, call)$globals
    nms_globals <- intersect(names, in_environment)
    nms_locals <- setdiff(names, nms_globals)

    locals <- rlang::env_get_list(envir, nms_locals, inherit = TRUE,
                                  last = topenv())
    check_locals_size(locals, call = call)

    validate_globals <- getOption("hipercow.validate_globals", FALSE)
    if (validate_globals && length(nms_globals) > 0) {
      globals <- rlang::env_get_list(envir, nms_globals, inherit = TRUE,
                                     last = topenv())
      globals <- vcapply(globals, rlang::hash)
    } else {
      globals <- NULL
    }

    list(locals = locals, globals = globals)
  }
}


task_submit_maybe <- function(id, driver, resources, root, call) {
  if (is.null(driver)) {
    FALSE
  } else {
    task_submit(id, resources = resources, driver = driver, root = root)
    TRUE
  }
}


check_locals_size <- function(locals, call = NULL) {
  if (length(locals) == 0) {
    return()
  }
  max_size <- getOption("hipercow.max_size_local", 1e6)
  if (!is.finite(max_size)) {
    return()
  }
  size <- vnapply(locals, utils::object.size)
  err <- names(locals)[size > max_size]
  if (length(err) > 0) {
    max_size_bytes <- format_bytes(max_size)
    cli::cli_abort(
      c("Object{?s} too large to save with task: {squote(err)}",
        x = "Objects saved with a hipercow task can only be {max_size_bytes}",
        i = paste("You can increase the limit by increasing the value of",
                  "the option 'hipercow.max_size_local', even using 'Inf' to",
                  "disable this check entirely"),
        i = paste("Better again, create large objects from your 'sources'",
                  "argument to your environment, and then advertise this",
                  "using the 'globals' argument")),
      call = call)
  }
}


check_function <- function(quo, call = NULL) {
  expr <- rlang::quo_get_expr(quo)
  if (rlang::is_call(expr, "::")) {
    value <- NULL
    name <- as.character(expr[[3]])
    namespace <- as.character(expr[[2]])
  } else if (rlang::is_call(expr, ":::")) {
    value <- expr
    name <- NULL
    namespace <- NULL
  } else if (rlang::is_symbol(expr)) {
    envir <- rlang::quo_get_env(quo)
    name <- as.character(expr)
    namespace <- NULL
    value <- rlang::env_get(envir, name, inherit = TRUE)
    if (!rlang::is_function(value)) {
      cli::cli_abort("The symbol '{name}' is not a function")
    }
  } else {
    name <- NULL
    namespace <- NULL
    value <- eval(expr, rlang::quo_get_env(quo))
    if (!rlang::is_function(value)) {
      cli::cli_abort("The value passed is not a function")
    }
  }
  list(name = name, namespace = namespace, value = value)
}


check_args <- function(args, call = NULL) {
  if (is.null(args)) {
    args <- list()
  }
  if (!is.list(args)) {
    cli::cli_abort("Expeced a list for 'args'", arg = "args", call = call)
  }
  args
}


## We use the driver for several parts of task creation/submission,
## but it's the submission that should trigger the error.  So we use
## this to validate we have a driver early then throw a nice error for
## the user.
driver_before_create <- function(driver, root, call) {
  tryCatch(
    hipercow_driver_select(driver, FALSE, root, call),
    error = function(e) {
      cli::cli_abort(
        "Can't submit task because unable to select driver",
        parent = e,
        call = call)
    })
}
