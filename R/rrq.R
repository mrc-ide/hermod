##' Create an rrq controller for your queue.  Use this to interact
##' with workers created with [hipercow_rrq_workers_submit()].  Proper
##' docs forthcoming, all interfaces are subject to some change.
##'
##' @title Create an rrq controller
##'
##' @param follow An optional default logical to use for tasks that
##'   may (or may not) be retried (this is rrq's retry, not
##'   hipercow's!). If not given we fall back on the global option
##'   `rrq.follow`, and if that is not set then `TRUE` (i.e., we do
##'   follow). The value `follow = TRUE` is potentially slower than
##'   `follow = FALSE` for some operations because we need to
##'   dereference every task id. If you never use `$task_retry` then
##'   this dereference never has an effect and we can skip it. See
##'   `vignette("fault-tolerance", package = "rrq")` for more
##'   information.
##'
##' @param driver Name of the driver to use.  The default (`NULL`)
##'   depends on your configured drivers; if you have no drivers
##'   configured we will error as we lack information required to
##'   proceed.  If you have exactly one driver configured we'll submit
##'   your task with it.  If you have more than one driver configured,
##'   then we will error, though in future versions we may fall back
##'   on a default driver if you have one configured.
##'
##' @inheritParams task_create_expr
##'
##' @return An [rrq::rrq_controller] object, with many methods.  See
##'   the [rrq docs](https://mrc-ide.github.io/) for information on
##'   using this.
##'
##' @export
hipercow_rrq_controller <- function(follow = NULL, driver = NULL, root = NULL) {
  root <- hipercow_root(root)
  driver <- hipercow_driver_select(driver, TRUE, root, rlang::current_env())
  rrq_prepare(driver, root, ..., call = rlang::current_env())
}


##' Submit workers to the cluster, use this in conjunction with
##' [hipercow_rrq_controller].  A worker may sit on a single core or a
##' whole node depending on how you set up `resources`.  We use the
##' `rrq` environment if it exists ([hipercow_environment_create])
##' otherwise we'll use the `default` environment.
##'
##' @title Submit rrq workers
##'
##' @param n The number of workers to submit. This is the only
##'   required argument.
##'
##' @inheritParams hipercow_rrq_controller
##'
##' @param resources A list generated by [hipercow_resources] giving
##'   the cluster resource requirements to run your task.
##'
##' @param envvars Environment variables as generated by
##'   [hipercow_envvars], which you might use to control your task.
##'
##' @param parallel Parallel configuration as generated by
##'   [hipercow_parallel], which defines which method, if any, will be
##'   used to initialise your worker for parallel execution (which
##'   means you have to think about parallelism at three levels at
##'   least, a diagram may help here).
##'
##' @param timeout Time to wait for workers to appear.
##'
##' @param progress Should we display a progress bar?
##'
##' @inheritParams task_eval
##'
##' @return A vector of worker ids
hipercow_rrq_workers_submit <- function(n,
                                        driver = NULL, resources = NULL,
                                        envvars = NULL, parallel = NULL,
                                        timeout = NULL, progress = NULL,
                                        root = NULL) {
  assert_scalar_integer(n, call = rlang::current_env())

  resources <- resources_validate(resources, driver, root)
  envvars <- prepare_envvars(envvars, driver, root, rlang::current_env())
  progress <- show_progress(progress, rlang::current_env())
  timeout <- timeout_value(timeout, rlang::current_env())

  r <- rrq_prepare(driver, root, call = rlang::current_env())
  queue_id <- r$queue_id
  worker_ids <- vcapply(seq_len(n), function(i) {
    worker_id <- sprintf("rrq-%s%s",
                         sub("^rrq:", "", queue_id),
                         ids::random_id(bytes = 10))
    expr <- rlang::expr({
      rrq::rrq_worker$new(!!queue_id, worker_id = !!worker_id)$loop()
    })
    task_create(root, "expression", ".", "empty", envvars, parallel,
                expr = expr)
    worker_id
  })
  fs::dir_create(dirname(path_workers))
  path_workers <- file.path(root$path$rrq, "workers", driver)
  append_lines(ids, path_workers)
  key_alive <- rrq_worker_expect(r, worker_ids)
  task_submit(id, resources = resources, driver = driver, root = root)
  rrq::rrq_worker_wait(r, key_alive, timeout = timeout, progress = progress)
}


rrq_prepare <- function(driver, root, ..., call = NULL) {
  ensure_package("rrq")
  ensure_package("redux")
  driver <- hipercow_driver_select(driver, TRUE, root, call)
  info <- cluster_info(driver, root)
  if (is.null(redis_url)) {
    cli::cli_abort("No redis support for '{driver}'")
  }
  con <- redux::hiredis(url = info$redis_url)
  path_id <- file.path(root$path$rrq, "id", driver)
  if (file.exists(path_id)) {
    queue_id <- readLines(path_id)
    cli::cli_alert_success("Using existing rrq queue '{queue_id}'")
    return(rrq::rrq_controller$new(queue_id, con, ...))
  }

  ## TODO: Some hard coding here that needs a bit of work, though
  ## practically these can all be worked around after initialisation
  ## easily enough.

  ## makes thinking about offload path much easier:
  withr::local_dir(root$path$root)
  offload_path <- file.path(root$path$rrq, "offload")
  rrq::rrq_configure(queue_id, con,
                     store_max_size = 100000,
                     offload_path = offload_path)

  worker_config <- rrq::rrq_worker_config(timeout_idle = 300, # 5 mins
                                          heartbeat_period = 60)
  r$worker_config_save("localhost", worker_config)

  queue_id <- ids::random_id(bytes = 4)
  r <- rrq::rrq_controller$new(queue_id, con, ...)
  r$envir(function(e) {
    nm <- if (hipercow_environment_exists("rrq")) "rrq" else "default"
    data <- hipercow_environment_load(nm)
    for (p in packages) {
      library(p, character.only = TRUE)
    }
    for (s in sources) {
      sys.source(s, envir = envir)
    }
  }, notify = FALSE)
  fs::dir_create(dirname(path_id))
  cli::cli_alert_success("Created new rrq queue '{queue_id}'")
  writeLines(queue_id, path_id)
}
