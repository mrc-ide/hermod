% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/task-create.R
\name{task_create_call}
\alias{task_create_call}
\title{Create task from call}
\usage{
task_create_call(
  fn,
  args,
  environment = "default",
  submit = NULL,
  resources = NULL,
  envvars = NULL,
  parallel = NULL,
  root = NULL
)
}
\arguments{
\item{fn}{The function to call.}

\item{args}{A list of arguments to pass to the function}

\item{environment}{Name of the hipercow environment to evaluate the
task within.}

\item{resources}{A list generated by \link{hipercow_resources} giving
the cluster resource requirements to run your task.}

\item{envvars}{Environment variables as generated by
\link{hipercow_envvars}, which you might use to control your task.}

\item{parallel}{Parallel configuration as generated by
\link{hipercow_parallel}, which defines which method, if any, will be used
to initialise your task for parallel execution.}

\item{root}{A hipercow root, or path to it. If \code{NULL} we search up
your directory tree.}
}
\value{
A task id, a string of hex characters. Use this to
interact with the task.
}
\description{
Create a task based on a function call.  This is fairly similar to
\link[callr:r]{callr::r}, and forms the basis of \code{\link[=lapply]{lapply()}}-like task
submission.  Sending a call may have slightly different semantics
than you expect if you send a closure (a function that binds
data), and we may change behaviour here until we find a happy set
of compromises.  See Details for more on this.  The expression
\code{task_create_call(f, list(a, b, c))} is similar to
\code{task_create_expr(f(a, b, c))}, use whichever you prefer.
}
\details{
Things are pretty unambiguous when you pass in a function from a
package, especially when you refer to that package with its
namespace (e.g. \code{pkg::fn}).

If you pass in the name \emph{without a namespace} from a package that
you have loaded with \code{library()} locally but you have not loaded
with \code{library} within your hipercow environment, we may not do the
right thing and you may see your task fail, or find a different
function with the same name.  We may change the semantics here in
a future version to attach your package immediately before running
the task.

If you pass in an anonymous function (e.g., \code{function(x) x + 1})
we may or may not do the right thing with respect to environment
capture.  We never capture the global environment so if your
function is a closure that tries to bind a symbol from the global
environment it will not work.  Like with \code{callr::r}, anonymous
functions will be easiest to think about where they are fully self
contained (i.e., all inputs to the functions come through \code{args}).
If you have bound a \emph{local} environment, we may do slightly
better, but semantics here are undefined and subject to change.

R does some fancy things with function calls that we don't try to
replicate.  In particular you may have noticed that this works:

\if{html}{\out{<div class="sourceCode">}}\preformatted{c <- "x"
c(c, c) # a vector of two "x"'s
}\if{html}{\out{</div>}}

You can end up in this situation locally with:

\if{html}{\out{<div class="sourceCode">}}\preformatted{f <- function(x) x + 1
local(\{
  f <- 1
  f(f) # 2
\})
}\if{html}{\out{</div>}}

this is because when R looks for the symbol for the call it skips
over non-function objects.  We don't reconstruct environment
chains in exactly the same way as you would have locally so this
is not possible.
}
