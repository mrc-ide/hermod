% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/task-retry.R
\name{task_retry}
\alias{task_retry}
\title{Retry a task}
\usage{
task_retry(id, submit = NULL, resources = NULL, root = NULL)
}
\arguments{
\item{id}{The identifier or identifiers of tasks to retry.}

\item{submit}{Control over task submission. This will expand over
time once we support specifying resources. The most simple
interface is to use \code{TRUE} here to automatically submit a task,
using your default configuration, or \code{FALSE} to prevent
submission.  The default \code{NULL} will submit a task if a driver
is configured.}

\item{resources}{A list generated by \link{hipercow_resources} giving
the cluster resource requirements to run your task.}

\item{root}{A hipercow root, or path to it. If \code{NULL} we search up
your directory tree.}
}
\value{
New identifiers for the retried tasks
}
\description{
Retry one or more tasks.  This creates a new task that copies the
work of the old one.  Most of the time this is transparent.  We'll
document this in the "advanced" vignette once it's written.
}
\details{
This ends up being a little more complicated than ideal in order
to keep things relatively fast, while keeping our usual guarantees
about race conditions etc.  Basically; retrying is the only way a
task can move out of a terminal state but it still does not modify
the existing task.  Instead, we keep a separate register of
whether a task has been retried or not.  Each time we retry we
write into this register.  When you query about the status etc of
a task you can then add a \code{follow} argument to control whether or
not we check the register.  We assume that you never call this in
parallel; if you do then retries may be lost.  You can run
\code{task_retry(NULL)} to refresh the cached copy of the retry map if
you need to.
}
\examples{
hipercow_example_helper()

# For demonstration, we just generate random numbers as then it's
# more obvious that things have been rerun:
id1 <- task_create_expr(runif(1))
task_wait(id1)
task_result(id1)

# Now retry the task and get the retried result:
id2 <- task_retry(id1)
task_wait(id2)
task_result(id2)

# After a retry, both the original and derived tasks know about
# each other:
task_info(id1)
task_info(id2)

# By default every task will "follow" and access the most recent
# task in the chain:
task_value(id1) == task_value(id2)

# You can prevent this by passing follow = FALSE to get the value
# of this particular attempt:
task_value(id1, follow = FALSE)

# Tasks can be retried as many times as needed, creating a
# chain. It does not matter which task you retry as we always
# follow all the way to the end of the chain before retrying:
id3 <- task_retry(id1)
task_info(id1, follow = FALSE)
task_info(id3)
}
