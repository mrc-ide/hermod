% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/task-retry.R
\name{task_retry}
\alias{task_retry}
\title{Retry a task}
\usage{
task_retry(id, submit = NULL, root = NULL)
}
\arguments{
\item{id}{The identifier or identifiers of tasks to retry.}

\item{submit}{Control over task submission. This will expand over
time once we support specifying resources. The most simple
interface is to use \code{TRUE} here to automatically submit a task,
using your default configuration, or \code{FALSE} to prevent
submission.  The default \code{NULL} will submit a task if a driver
is configured.}

\item{root}{A hipercow root, or path to it. If \code{NULL} we search up
your directory tree.}
}
\value{
New identifiers for the retried tasks
}
\description{
Retry one or more tasks.  This creates a new task that copies the
work of the old one.  Most of the time this is transparent.  We'll
document this in the "advanced" vignette once it's written.
}
\details{
This ends up being a little more complicated than ideal in order
to keep things relatively fast, while keeping our usual guarantees
about race conditions etc.  Basically; retrying is the only way a
task can move out of a terminal state but it still does not modify
the existing task.  Instead, we keep a separate register of
whether a task has been retried or not.  Each time we retry we
write into this register.  When you query about the status etc of
a task you can then add a \code{follow} argument to control whether or
not we check the register.  We assume that you never call this in
parallel; if you do then retries may be lost.  You can run
\code{task_retry(NULL)} to refresh the cached copy of the retry map if
you need to.
}
