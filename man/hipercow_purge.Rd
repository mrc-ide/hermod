% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/task-purge.R
\name{hipercow_purge}
\alias{hipercow_purge}
\title{Purge tasks}
\usage{
hipercow_purge(
  task_ids = NULL,
  finished_before = NULL,
  in_bundle = NULL,
  with_status = NULL,
  root = NULL
)
}
\arguments{
\item{task_ids}{A character vector of task identifiers.  Typically
if you provide this you will not provide any other filters.}

\item{finished_before}{A date, time, or \link{difftime} object
representing the time or time ago that a task finished.
Everything prior to this will be deleted.}

\item{in_bundle}{A character vector of bundle names. Wild cards
are supported using shell (glob) syntax, rather than regular
expression syntax.  So use \verb{data_*} to match all bundles that
start with \code{data_} (see \link{glob2rx} for details).  It is an error
if \emph{no} bundles are matched, but not an error if any individual
pattern does not match.}

\item{with_status}{A character vector of statuses to match.  We
only purge tasks that match these statuses.  Valid statuses to
use are \code{created}, \code{success}, \code{failure} and \code{cancelled} (note
you cannot select tasks with status of \code{submitted} or \code{running};
use \link{task_cancel} for these first).}

\item{root}{A hipercow root, or path to it. If \code{NULL} we search up
your directory tree.}
}
\value{
A character vector of deleted identifiers, invisibly.
}
\description{
Purge (delete) hipercow tasks.  This is a destructive operation
that cannot be undone and can have unintended consequences!
However, if you are running short of space and don't want to just
delete everything and start again (which is our general
recommendation), this function provides a mechanism for cleaning
up tasks that you no longer need.
}
\details{
Most of the arguments describe \emph{filters} over your tasks.  We
delete the intersection of these filters (not the union), and you
must provide at least one filter.  So to delete all tasks that
were created more than a week ago you could write:

\if{html}{\out{<div class="sourceCode">}}\preformatted{hipercow_purge(created_before = as.difftime(1, units = "weeks"))
}\if{html}{\out{</div>}}

but to restrict this to only tasks in that have \emph{also failed} you
could write

\if{html}{\out{<div class="sourceCode">}}\preformatted{hipercow_purge(created_before = "1 week", with_status = "failed")
}\if{html}{\out{</div>}}
}
\section{Consequences of deletion}{
A nonexhaustive list:
\itemize{
\item If you delete a task that is queued or running, hipercow has
\href{https://en.wikipedia.org/wiki/Undefined_behavior}{undefined behaviour},
but we will try and stop you doing this
\item If you delete a task that is part of a \link{task_retry} chain, then
all tasks (both upstream and downstream in that chain) are
deleted
\item Once we support task dependencies (mrc-4797), deleting tasks
will mark any unrun dependent task as impossible, or perhaps
delete it too, or prevent you from deleting the task; we've not
decided yet
\item You may have a bundle that references a task that you delete, in
which case the bundle will not behave as expected.  As a result
we delete all bundles that reference a deleted tasks
\item Deleted bundles or deleted tasks that you hold identifiers to
before deletion will not behave as expected, with tasks reported
missing.  Restarting your session is probably the safest thing
to do after purging.
\item We can't prevent race conditions, so if you are purging tasks at
the same time you are also retrying tasks that you will purge,
you'll create tasks that we might not want to allow, and these
tasks will fail in peculiar ways.
}
}

\examples{
cleanup <- hipercow_example_helper()

# Here are some tasks that have finished running:
bundle <- task_create_bulk_expr(sqrt(x), data.frame(x = 1:5),
                                bundle_name = "mybundle")
hipercow_bundle_wait(bundle)

# Purge all tasks contained in any bundle starting with "my":
hipercow_purge(in_bundle = "my*")

cleanup()
}
